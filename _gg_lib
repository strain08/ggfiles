#!/usr/bin/env bash
#echo "_gg_lib: "

os=$(uname -s)

list_layers() {
	for dir in "$GG_BACKUP_ROOT"/*/; do
		[ -d "$dir" ] || continue
		basename "$dir"
	done
}

# prints colored text
print_style () {
    local text=$1

    local colorval=$3

    case $colorval in
		purple)
			COLOR="35m"
			;;
        orange)
            # 256-color orange (works on terminals that support 256 colors)
            COLOR="38;5;208m"
            ;;
		green)
			COLOR="32m"
			;;
		yellow)
			COLOR="33m"
			;;
		red)
			COLOR="31m"
			;;
		iwhite)
			COLOR="97m"
			;;
		*)
			COLOR="0m"
			;;
    esac


    STARTCOLOR="\e[$COLOR";
    ENDCOLOR="\e[0m";

    printf "$STARTCOLOR%$2b$ENDCOLOR" "$text";
}

# Detect if a file is in the user's home directory
detect_home_file() {
    local file_path="$1"

    # Ensure HOME is set and absolute
    if [ -z "$HOME" ] || [[ ! "$HOME" =~ ^/ ]]; then
        echo "false"
        return
    fi

    # Normalize the path (resolve symlinks)
    local normalized
    if [ "$os" == "Linux" ]; then
        normalized=$(realpath "$file_path" 2>/dev/null)
    else
        normalized=$(realpath -q "$file_path" 2>/dev/null)
    fi

    [ -z "$normalized" ] && echo "false" && return

    # Check if file is under HOME directory
    if [[ "$normalized" == "$HOME" ]] || [[ "$normalized" == "$HOME"/* ]]; then
        echo "true"
    else
        echo "false"
    fi
}

# Get relative path from HOME directory
get_home_relative_path() {
    local file_path="$1"

    # Normalize the path
    local normalized
    if [ "$os" == "Linux" ]; then
        normalized=$(realpath "$file_path" 2>/dev/null)
    else
        normalized=$(realpath -q "$file_path" 2>/dev/null)
    fi

    [ -z "$normalized" ] && echo "" && return

    # Strip HOME prefix
    local relative="${normalized#$HOME/}"

    # If path is exactly HOME, return "."
    if [ "$relative" == "$normalized" ]; then
        echo "."
    else
        echo "$relative"
    fi
}

# Get the correct metadata file path based on file type
get_metadata_file() {
    local file_type="${1:-ROOT}"  # Default to ROOT

    if [ -z "$_LAYER_DIR" ]; then
        echo "Error: _LAYER_DIR not set" >&2
        return 1
    fi

    if [ "$file_type" == "HOME" ]; then
        echo "$_LAYER_DIR/.permissions_home"
    else
        echo "$_LAYER_DIR/.permissions_root"
    fi
}

# Store file metadata (permissions and ownership)
# New signature: store_metadata(file, file_type) - metadata file is determined internally
store_metadata() {
    local file="$1"
    local file_type="${2:-ROOT}"  # Default to ROOT, can be HOME

    # Get the correct metadata file based on type
    local metadata_file
    metadata_file=$(get_metadata_file "$file_type") || return 1

    # Get the new metadata line (without type annotation)
    local new_metadata
    if [ "$os" == "Linux" ]; then
        new_metadata=$(stat -c "%n %a %u %g" "$file")
    else
        # FreeBSD/macOS
        new_metadata=$(stat -f "%N %Mp%Lp %u %g" "$file")
    fi

    # Create metadata file if it doesn't exist
    if [ ! -f "$metadata_file" ]; then
        touch "$metadata_file" || {
            echo "Error: Cannot create metadata file" >&2
            exit 1
        }
        chmod 666 "$metadata_file" || {
            echo "Error: Cannot set permissions on metadata file. Try: sudo ggadd <file>" >&2
            exit 1
        }
    fi

    # Escape special characters in filename for sed pattern
    local escaped_file=$(printf '%s\n' "$file" | sed 's/[[\.*^$(){}?+|/]/\\&/g')
    # Escape special characters for sed replacement (escape backslash and hash since we use # as delimiter)
    local escaped_metadata=$(printf '%s\n' "$new_metadata" | sed 's/[\\#]/\\&/g')

    # Check if entry exists and replace or append
    if grep -q "^$escaped_file " "$metadata_file" 2>/dev/null; then
        # Replace existing entry - use # as delimiter (works on both Linux and FreeBSD)
        if [ "$os" == "Linux" ]; then
            sed -i "s#^$escaped_file .*#$escaped_metadata#" "$metadata_file"
        else
            # FreeBSD/macOS requires backup extension
            sed -i '' "s#^$escaped_file .*#$escaped_metadata#" "$metadata_file"
        fi
    else
        # Add new entry
        echo "$new_metadata" >> "$metadata_file"
    fi

    # Ensure metadata file is readable and writable by all
    chmod 666 "$metadata_file" || {
        echo "Error: Cannot set permissions on metadata file. Try: sudo ggadd <file>" >&2
        exit 1
    }
}


# Remove metadata for files that no longer exist in backup
# Simplified: no type filtering needed since each metadata file is dedicated to one type
cleanup_metadata() {
    local backup_dir="$1"
    local metadata_file="$2"
    local file_type="${3:-ROOT}"  # Kept for compatibility but not used for filtering

    [ ! -f "$metadata_file" ] && return 0
    [ ! -d "$backup_dir" ] && return 0

    # Create a temporary file for cleaned metadata
    local temp_file="${metadata_file}.cleanup_tmp"
    > "$temp_file"
    chmod 666 "$temp_file" || {
        echo "Error: Cannot set permissions on temporary metadata file. Try: sudo ggupdate" >&2
        exit 1
    }

    # Read each line from metadata file
    # Since metadata file is dedicated to one type, we just check file existence
    while read -r line; do
        [ -z "$line" ] && continue

        # Parse: filepath perms uid gid (simplified format, no type annotation)
        local file_path
        file_path=$(echo "$line" | awk '{print $1}')

        # Check if the file exists in the backup directory
        if [ -f "$backup_dir/$file_path" ]; then
            # Keep this metadata entry if file exists in backup
            echo "$line" >> "$temp_file"
        fi
        # Skip entries whose files no longer exist in backup
    done < "$metadata_file"

    # Replace original metadata file with cleaned version
    mv "$temp_file" "$metadata_file" || {
        echo "Error: Cannot update metadata file. Try: sudo ggupdate" >&2
        exit 1
    }
    chmod 666 "$metadata_file" || {
        echo "Error: Cannot set permissions on metadata file. Try: sudo ggupdate" >&2
        exit 1
    }
}

# Restore files metadata from metadata file
# New signature: restore_metadata(metadata_file, file_type)
restore_metadata() {
    local metadata_file="$1"
    local file_type="${2:-ROOT}"  # ROOT or HOME - determines ownership behavior

    [ ! -f "$metadata_file" ] && return 0

    while read -r line; do
        [ -z "$line" ] && continue

        # Parse simplified format: filepath perms uid gid (no type annotation)
        local file
        local perms
        local uid
        local gid

        file=$(echo "$line" | awk '{print $1}')
        perms=$(echo "$line" | awk '{print $2}')
        uid=$(echo "$line" | awk '{print $3}')
        gid=$(echo "$line" | awk '{print $4}')

        # For HOME files, override stored uid/gid with current user
        if [ "$file_type" == "HOME" ]; then
            uid=$(id -u)
            gid=$(id -g)
        fi

        if [ -e "$file" ]; then
            chmod "$perms" "$file" 2>/dev/null || echo "Warning: Could not set permissions on $file"
            chown "$uid:$gid" "$file" 2>/dev/null || echo "Warning: Could not set ownership on $file (may need sudo)"
        fi
    done < "$metadata_file"
}

