#!/usr/bin/env bash
#echo "_gg_lib: "

os=$(uname -s)

list_layers() {
	for dir in "$GG_BACKUP_ROOT"/*/; do
		[ -d "$dir" ] || continue
		basename "$dir"
	done
}

# prints colored text
print_style () {
    local text=$1

    local colorval=$3

    case $colorval in
		purple)
			COLOR="35m"
			;;
        orange)
            # 256-color orange (works on terminals that support 256 colors)
            COLOR="38;5;208m"
            ;;
		green)
			COLOR="32m"
			;;
		yellow)
			COLOR="33m"
			;;
		red)
			COLOR="31m"
			;;
		iwhite)
			COLOR="97m"
			;;
		*)
			COLOR="0m"
			;;
    esac


    STARTCOLOR="\e[$COLOR";
    ENDCOLOR="\e[0m";

    printf "$STARTCOLOR%$2b$ENDCOLOR" "$text";
}

# Detect if a file is in the user's home directory
detect_home_file() {
    local file_path="$1"

    # Ensure HOME is set and absolute
    if [ -z "$HOME" ] || [[ ! "$HOME" =~ ^/ ]]; then
        echo "false"
        return
    fi

    # Normalize the path (resolve symlinks)
    local normalized
    if [ "$os" == "Linux" ]; then
        normalized=$(realpath "$file_path" 2>/dev/null)
    else
        normalized=$(realpath -q "$file_path" 2>/dev/null)
    fi

    [ -z "$normalized" ] && echo "false" && return

    # Check if file is under HOME directory
    if [[ "$normalized" == "$HOME" ]] || [[ "$normalized" == "$HOME"/* ]]; then
        echo "true"
    else
        echo "false"
    fi
}

# Get relative path from HOME directory
get_home_relative_path() {
    local file_path="$1"

    # Normalize the path
    local normalized
    if [ "$os" == "Linux" ]; then
        normalized=$(realpath "$file_path" 2>/dev/null)
    else
        normalized=$(realpath -q "$file_path" 2>/dev/null)
    fi

    [ -z "$normalized" ] && echo "" && return

    # Strip HOME prefix
    local relative="${normalized#$HOME/}"

    # If path is exactly HOME, return "."
    if [ "$relative" == "$normalized" ]; then
        echo "."
    else
        echo "$relative"
    fi
}

# Store file metadata (permissions and ownership)
store_metadata() {
    local file="$1"
    local metadata_file="$2"
    local file_type="${3:-ROOT}"  # Default to ROOT, can be HOME

    # Get the new metadata line
    local new_metadata
    if [ "$os" == "Linux" ]; then
        new_metadata=$(stat -c "%n %a %u %g" "$file")
    else
        # FreeBSD/macOS
        new_metadata=$(stat -f "%N %Mp%Lp %u %g" "$file")
    fi

    # Append type annotation: filepath|TYPE perms uid gid
    new_metadata="$new_metadata|$file_type"

    # Create metadata file if it doesn't exist
    [ ! -f "$metadata_file" ] && touch "$metadata_file"

    # Escape special characters in filename for sed pattern
    local escaped_file=$(printf '%s\n' "$file" | sed 's/[[\.*^$(){}?+|/]/\\&/g')
    # Escape special characters for sed replacement (escape backslash and hash since we use # as delimiter)
    local escaped_metadata=$(printf '%s\n' "$new_metadata" | sed 's/[\\#]/\\&/g')

    # Check if entry exists and replace or append
    if grep -q "^$escaped_file " "$metadata_file" 2>/dev/null; then
        # Replace existing entry - use # as delimiter (works on both Linux and FreeBSD)
        if [ "$os" == "Linux" ]; then
            sed -i "s#^$escaped_file .*#$escaped_metadata#" "$metadata_file"
        else
            # FreeBSD/macOS requires backup extension
            sed -i '' "s#^$escaped_file .*#$escaped_metadata#" "$metadata_file"
        fi
    else
        # Add new entry
        echo "$new_metadata" >> "$metadata_file"
    fi
}


# Remove metadata for files that no longer exist in backup
cleanup_metadata() {
    local backup_dir="$1"
    local metadata_file="$2"
    local file_type="${3:-ROOT}"  # Default to ROOT, can be HOME

    [ ! -f "$metadata_file" ] && return 0
    [ ! -d "$backup_dir" ] && return 0

    # Create a temporary file for cleaned metadata
    local temp_file="${metadata_file}.cleanup_tmp"
    > "$temp_file"

    # Read each line from metadata file
    while read -r line; do
        [ -z "$line" ] && continue

        # Parse: filepath perms uid gid|TYPE (new format) or filepath perms uid gid (old format)
        local file_path
        local stored_type

        if [[ "$line" =~ \| ]]; then
            # New format with type annotation: filepath perms uid gid|TYPE
            # Extract type (after the pipe)
            stored_type=$(echo "$line" | cut -d'|' -f2)
            # Extract filepath (first field before the pipe)
            file_path=$(echo "$line" | cut -d'|' -f1 | awk '{print $1}')
        else
            # Old format without type annotation - treat as ROOT
            file_path=$(echo "$line" | awk '{print $1}')
            stored_type="ROOT"
        fi

        # If type matches our target type, only keep if file still exists
        if [ "$stored_type" == "$file_type" ]; then
            if [ -f "$backup_dir/$file_path" ]; then
                # Keep this metadata entry if file exists in backup
                echo "$line" >> "$temp_file"
            fi
            # Skip entries whose files no longer exist in backup
        else
            # Keep entries that don't match our target type (preserve other types)
            echo "$line" >> "$temp_file"
        fi
    done < "$metadata_file"

    # Replace original metadata file with cleaned version
    mv "$temp_file" "$metadata_file"
}

# Restore files metadata from metadata file
restore_metadata() {
    local metadata_file="$1"

    [ ! -f "$metadata_file" ] && return 0

    while read -r line; do
        [ -z "$line" ] && continue

        # Parse: filepath perms uid gid|TYPE (new format) or filepath perms uid gid (old format)
        local file
        local perms
        local uid
        local gid
        local file_type

        if [[ "$line" =~ \| ]]; then
            # New format with type annotation: filepath perms uid gid|TYPE
            local metadata_part=$(echo "$line" | cut -d'|' -f1)
            file_type=$(echo "$line" | cut -d'|' -f2)
            file=$(echo "$metadata_part" | awk '{print $1}')
            perms=$(echo "$metadata_part" | awk '{print $2}')
            uid=$(echo "$metadata_part" | awk '{print $3}')
            gid=$(echo "$metadata_part" | awk '{print $4}')
        else
            # Old format without type annotation - treat as ROOT
            file=$(echo "$line" | awk '{print $1}')
            perms=$(echo "$line" | awk '{print $2}')
            uid=$(echo "$line" | awk '{print $3}')
            gid=$(echo "$line" | awk '{print $4}')
            file_type="ROOT"
        fi

        # For HOME files, use current user's uid/gid
        if [ "$file_type" == "HOME" ]; then
            uid=$(id -u)
            gid=$(id -g)
        fi

        if [ -e "$file" ]; then
            chmod "$perms" "$file" 2>/dev/null || echo "Warning: Could not set permissions on $file"
            chown "$uid:$gid" "$file" 2>/dev/null || echo "Warning: Could not set ownership on $file (may need sudo)"
        fi
    done < "$metadata_file"
}

# Generate HTML overview of backed up files
generate_html_overview() {
    local work_dir="$1"
    local layer_dir="$2"
    local layer_name="$3"
    local home_dir="${4:-}"  # Optional home directory
    local html_file="$layer_dir/content.html"

    [ ! -d "$work_dir" ] && [ -z "$home_dir" ] && return 1

    # Get total file count and size
    local total_files=0
    local total_size=0
    local generation_date=$(date)
    if [ ! -f "$GG_BACKUP_ROOT/webroot.conf" ]; then
        echo "$GG_BACKUP_ROOT/webroot.conf not found."
        exit 1
    fi
    #source GG_WEB_ROOT
    . "$GG_BACKUP_ROOT/webroot.conf"

    # Start HTML document
    cat > "$html_file" << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backup Overview</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header { background: #2c3e50; color: white; padding: 20px; border-radius: 8px 8px 0 0; }
        .header h1 { margin: 0; font-size: 24px; }
        .stats { display: flex; gap: 20px; margin-top: 10px; font-size: 14px; opacity: 0.9; }
        .search { padding: 20px; border-bottom: 1px solid #eee; }
        .search input { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px; }
        .content { padding: 20px; }
        .folder { margin: 10px 0; }
        .folder-header { cursor: pointer; font-weight: bold; padding: 5px; background: #ecf0f1; border-radius: 4px; display: flex; align-items: center; }
        .folder-header:hover { background: #d5dbdb; }
        .folder-icon { margin-right: 8px; }
        .folder-content { margin-left: 20px; display: none; }
        .folder-content.expanded { display: block; }
        .file { padding: 5px 0; display: flex; align-items: center; border-bottom: 1px solid #f8f9fa; }
        .file:hover { background: #f8f9fa; }
        .file-icon { margin-right: 8px; color: #7f8c8d; }
        .file-name { flex: 1; }
        .file-name a { text-decoration: none; color: #2980b9; }
        .file-name a:hover { text-decoration: underline; }
        .file-meta { font-size: 12px; color: #7f8c8d; text-align: right; min-width: 200px; }
        .hidden { display: none; }

        @media (prefers-color-scheme: dark) {
            body { background: #1a1a1a; }
            .container { background: #2d2d2d; box-shadow: 0 2px 10px rgba(0,0,0,0.3); }
            .header { background: #34495e; }
            .search { border-bottom: 1px solid #444; }
            .search input { background: #3a3a3a; border: 1px solid #555; color: white; }
            .search input::placeholder { color: #bbb; }
            .folder-header { background: #3a3a3a; color: #e0e0e0; }
            .folder-header:hover { background: #4a4a4a; }
            .file { border-bottom: 1px solid #3a3a3a; color: #e0e0e0; }
            .file:hover { background: #3a3a3a; }
            .file-icon { color: #bbb; }
            .file-name a { color: #5dade2; }
            .file-meta { color: #bbb; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üóÇÔ∏è Backup Overview</h1>
EOF

    echo "            <div class=\"stats\">" >> "$html_file"
    echo "                <span>üìÅ Layer: <strong>$layer_name</strong></span>" >> "$html_file"
    echo "                <span>üïê Generated: $generation_date</span>" >> "$html_file"

    # Calculate stats for both _root/ and _home/
    local root_files=0
    local root_size=0
    local home_files=0
    local home_size=0

    if [ -d "$work_dir" ]; then
        cd "$work_dir" || return 1
        root_files=$(find . -type f 2>/dev/null | wc -l)
        if [ "$os" == "Linux" ]; then
            root_size=$(find . -type f 2>/dev/null -exec stat -c%s {} \; | awk '{sum+=$1} END {print sum}')
        else
            root_size=$(find . -type f 2>/dev/null -exec stat -f%z {} \; | awk '{sum+=$1} END {print sum}')
        fi
    fi

    if [ -n "$home_dir" ] && [ -d "$home_dir" ]; then
        cd "$home_dir" || return 1
        home_files=$(find . -type f 2>/dev/null | wc -l)
        if [ "$os" == "Linux" ]; then
            home_size=$(find . -type f 2>/dev/null -exec stat -c%s {} \; | awk '{sum+=$1} END {print sum}')
        else
            home_size=$(find . -type f 2>/dev/null -exec stat -f%z {} \; | awk '{sum+=$1} END {print sum}')
        fi
    fi

    total_files=$((root_files + home_files))
    total_size=$((root_size + home_size))

    # Convert bytes to human readable
    if [ "$total_size" -gt 1073741824 ]; then
        size_display="$(( total_size / 1073741824 )) GB"
    elif [ "$total_size" -gt 1048576 ]; then
        size_display="$(( total_size / 1048576 )) MB"
    elif [ "$total_size" -gt 1024 ]; then
        size_display="$(( total_size / 1024 )) KB"
    else
        size_display="$total_size bytes"
    fi

    echo "                <span>üìÑ Files: <strong>$total_files</strong> (System: $root_files, Home: $home_files)</span>" >> "$html_file"
    echo "                <span>üíæ Size: <strong>$size_display</strong></span>" >> "$html_file"

    cat >> "$html_file" << 'EOF'
            </div>
        </div>
        <div class="search">
            <input type="text" id="searchBox" placeholder="üîç Search files..." onkeyup="filterFiles()">
        </div>
        <div class="content">
EOF

    # Function to generate file tree for a directory
    generate_tree_section() {
        local dir="$1"
        local section_name="$2"
        local section_id="$3"
        local url_prefix="$4"

        echo "            <h2 style=\"margin-top: 20px; border-top: 2px solid #eee; padding-top: 10px;\">$section_name</h2>" >> "$html_file"
        echo "            <div id=\"$section_id\">" >> "$html_file"

        if [ ! -d "$dir" ]; then
            echo "                <p style=\"color: #7f8c8d; font-style: italic;\">No backups in this section</p>" >> "$html_file"
            echo "            </div>" >> "$html_file"
            return
        fi

        cd "$dir" || return 1

        # Create directory structure
        find . -type d | sort | while read -r subdir; do
            [ "$subdir" = "." ] && continue

            dir_name=$(basename "$subdir")
            dir_path=${subdir#./}
            dir_level=$(echo "$dir_path" | tr -cd '/' | wc -c)

            echo "                <div class=\"folder\" style=\"margin-left: ${dir_level}0px;\">" >> "$html_file"
            echo "                    <div class=\"folder-header\" onclick=\"toggleFolder(this)\">" >> "$html_file"
            echo "                        <span class=\"folder-icon\">üìÅ</span>" >> "$html_file"
            echo "                        <span>$dir_name/</span>" >> "$html_file"
            echo "                    </div>" >> "$html_file"
            echo "                    <div class=\"folder-content\">" >> "$html_file"

            # Add files in this directory
            find "$subdir" -maxdepth 1 -type f | sort | while read -r file; do
                [ ! -f "$file" ] && continue

                file_name=$(basename "$file")
                file_path=${file#./}
                web_url="$url_prefix/$file_path"

                # Get file metadata
                if [ "$os" == "Linux" ]; then
                    file_size=$(stat -c%s "$file" 2>/dev/null || echo "0")
                    file_perms=$(stat -c%a "$file" 2>/dev/null || echo "---")
                    file_mtime=$(stat -c%y "$file" 2>/dev/null | cut -d' ' -f1)
                else
                    file_size=$(stat -f%z "$file" 2>/dev/null || echo "0")
                    file_perms=$(stat -f%Mp%Lp "$file" 2>/dev/null || echo "---")
                    file_mtime=$(stat -f%Sm -t%Y-%m-%d "$file" 2>/dev/null)
                fi

                # Convert file size to human readable
                if [ "$file_size" -gt 1048576 ]; then
                    size_display="$(( file_size / 1048576 )) MB"
                elif [ "$file_size" -gt 1024 ]; then
                    size_display="$(( file_size / 1024 )) KB"
                else
                    size_display="$file_size B"
                fi

                echo "                        <div class=\"file\">" >> "$html_file"
                echo "                            <span class=\"file-icon\">üìÑ</span>" >> "$html_file"
                echo "                            <span class=\"file-name\"><a href=\"$web_url\" target=\"_blank\">$file_name</a></span>" >> "$html_file"
                echo "                            <span class=\"file-meta\">$size_display | $file_perms | $file_mtime</span>" >> "$html_file"
                echo "                        </div>" >> "$html_file"
            done

            echo "                    </div>" >> "$html_file"
            echo "                </div>" >> "$html_file"
        done

        # Add files in root directory of section
        find . -maxdepth 1 -type f | sort | while read -r file; do
            [ ! -f "$file" ] && continue

            file_name=$(basename "$file")
            file_path=${file#./}
            web_url="$url_prefix/$file_path"

            # Get file metadata
            if [ "$os" == "Linux" ]; then
                file_size=$(stat -c%s "$file" 2>/dev/null || echo "0")
                file_perms=$(stat -c%a "$file" 2>/dev/null || echo "---")
                file_mtime=$(stat -c%y "$file" 2>/dev/null | cut -d' ' -f1)
            else
                file_size=$(stat -f%z "$file" 2>/dev/null || echo "0")
                file_perms=$(stat -f%Mp%Lp "$file" 2>/dev/null || echo "---")
                file_mtime=$(stat -f%Sm -t%Y-%m-%d "$file" 2>/dev/null)
            fi

            # Convert file size to human readable
            if [ "$file_size" -gt 1048576 ]; then
                size_display="$(( file_size / 1048576 )) MB"
            elif [ "$file_size" -gt 1024 ]; then
                size_display="$(( file_size / 1024 )) KB"
            else
                size_display="$file_size B"
            fi

            echo "                <div class=\"file\">" >> "$html_file"
            echo "                    <span class=\"file-icon\">üìÑ</span>" >> "$html_file"
            echo "                    <span class=\"file-name\"><a href=\"$web_url\" target=\"_blank\">$file_name</a></span>" >> "$html_file"
            echo "                    <span class=\"file-meta\">$size_display | $file_perms | $file_mtime</span>" >> "$html_file"
            echo "                </div>" >> "$html_file"
        done

        echo "            </div>" >> "$html_file"
    }

    # Generate sections for ROOT and HOME files
    if [ -d "$work_dir" ]; then
        local root_url="$GG_WEB_ROOT/$(basename $GG_BACKUP_ROOT)/$layer_name/_root"
        generate_tree_section "$work_dir" "System Files (/root)" "root-section" "$root_url"
    fi

    if [ -n "$home_dir" ] && [ -d "$home_dir" ]; then
        local home_url="$GG_WEB_ROOT/$(basename $GG_BACKUP_ROOT)/$layer_name/_home"
        generate_tree_section "$home_dir" "Home Directory Files (~)" "home-section" "$home_url"
    fi

    # Close HTML document
    cat >> "$html_file" << 'EOF'
        </div>
    </div>

    <script>
        function toggleFolder(element) {
            const content = element.nextElementSibling;
            const icon = element.querySelector('.folder-icon');
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                icon.textContent = 'üìÅ';
            } else {
                content.classList.add('expanded');
                icon.textContent = 'üìÇ';
            }
        }

        function filterFiles() {
            const searchTerm = document.getElementById('searchBox').value.toLowerCase();
            const files = document.querySelectorAll('.file');
            const folders = document.querySelectorAll('.folder');

            files.forEach(file => {
                const fileName = file.querySelector('.file-name').textContent.toLowerCase();
                if (fileName.includes(searchTerm)) {
                    file.classList.remove('hidden');
                } else {
                    file.classList.add('hidden');
                }
            });

            // Show/hide folders based on visible files
            folders.forEach(folder => {
                const visibleFiles = folder.querySelectorAll('.file:not(.hidden)');
                if (visibleFiles.length > 0 || searchTerm === '') {
                    folder.classList.remove('hidden');
                } else {
                    folder.classList.add('hidden');
                }
            });
        }
    </script>
</body>
</html>
EOF

    echo "HTML overview generated: $html_file"
}


