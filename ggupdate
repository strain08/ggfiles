#!/usr/bin/env bash
. $(which _gg_check_root)
. $(which _gg_check_layer)
. $(which _gg_lib_html)

pwd_before_update=$(pwd)

# Update ROOT files
echo "Updating ROOT files in backup..."
cd "$_ROOT_DIR" || exit 1

printf "Updating files in backup ...\n"
tmp_errors=$(mktemp)
chmod $REPO_MODE "$tmp_errors" 2>/dev/null || true
tmp_filelist=$(mktemp)
chmod $REPO_MODE "$tmp_filelist" 2>/dev/null || true

# Generate file list and check for errors
if ! find . -type f | sed 's|^\./||' > "$tmp_filelist"; then
	printf "Error: Failed to generate file list from backup directory\n"
	rm "$tmp_errors" "$tmp_filelist"
	exit 1
else
	echo ---
	cat "$tmp_filelist"
	echo ---
fi

print_style ">>> RSYNC (ROOT)\n" "" orange
# Use rsync with the generated file list
rsync -avz --chmod=Du=rwx,Dg=rwx,Do=,Fu=rw,Fg=rw,Fo= --chown=:$REPO_GROUP --files-from="$tmp_filelist" / "$_ROOT_DIR" 2>"$tmp_errors"
if [ $? -ne 0 ]; then
	printf "There were errors updating ROOT backup files:\n"
	cat "$tmp_errors" | grep -E "rsync:"
	rm "$tmp_errors" "$tmp_filelist"
	exit 1
fi
print_style "<<< RSYNC (ROOT)\n" "" orange

rm "$tmp_errors" "$tmp_filelist"

# Update HOME files
if [ -d "$_HOME_DIR" ]; then
    echo "Updating HOME files in backup..."

    tmp_errors=$(mktemp)
    chmod $REPO_MODE "$tmp_errors" 2>/dev/null || true
    tmp_filelist_home=$(mktemp)
    chmod $REPO_MODE "$tmp_filelist_home" 2>/dev/null || true

    # Generate file list FROM THE BACKUP (not from HOME)
    # This ensures we ONLY update files that are already in backup
    cd "$_HOME_DIR" || exit 1
    if ! find . -type f | sed 's|^\./||' > "$tmp_filelist_home"; then
        printf "Error: Failed to generate file list from backup directory\n"
        rm "$tmp_errors" "$tmp_filelist_home"
        exit 1
    else
        echo ---
        cat "$tmp_filelist_home"
        echo ---
    fi

    print_style ">>> RSYNC (HOME)\n" "" orange
    # rsync to update backup from HOME directory
    # Uses --files-from with list FROM backup to sync only those files
    rsync -avz --chmod=Du=rwx,Dg=rwx,Do=,Fu=rw,Fg=rw,Fo= --chown=:$REPO_GROUP --files-from="$tmp_filelist_home" "$HOME/" "$_HOME_DIR" 2>"$tmp_errors"
    result_home=$?
    if [ $result_home -ne 0 ]; then
        printf "There were errors updating HOME backup files:\n"
        cat "$tmp_errors" | grep -E "rsync:"
    fi
    print_style "<<< RSYNC (HOME)\n" "" orange

    rm "$tmp_errors" "$tmp_filelist_home"
fi

printf "Updating metadata...\n"

# cleanup and update ROOT metadata
metadata_root="$_LAYER_DIR/.permissions_root"
printf "Cleaning ROOT metadata..."
cleanup_metadata "$_ROOT_DIR" "$metadata_root" "ROOT"

# Update ROOT metadata
files_list=$(find "$_ROOT_DIR" -type f 2>/dev/null)
for backed_up_file in $files_list; do
	printf "."
    # Convert backup path to original system path
    original_file="${backed_up_file#"$_ROOT_DIR"}"
    if [ -f "$original_file" ]; then
		# add or update metadata - new signature: store_metadata(file, file_type)
        store_metadata "$original_file" "ROOT"
    fi
done
printf "Done\n"

# cleanup and update HOME metadata
if [ -d "$_HOME_DIR" ]; then
    metadata_home="$_LAYER_DIR/.permissions_home"
    printf "Cleaning HOME metadata..."
    cleanup_metadata "$_HOME_DIR" "$metadata_home" "HOME"

    # Update HOME metadata
    cd "$_HOME_DIR" || exit 1
    files_list=$(find . -type f 2>/dev/null)
    for backed_up_file in $files_list; do
        printf "."
        # Convert backup path to relative path
        relative_file="${backed_up_file#./}"
        if [ -f "$HOME/$relative_file" ]; then
            # Store with HOME type - new signature: store_metadata(file, file_type)
            store_metadata "$relative_file" "HOME"
        fi
    done
    printf "Done\n"
fi

cd "$pwd_before_update" || exit 1

# Generate HTML overview
generate_html_overview "$_ROOT_DIR" "$_LAYER_DIR" "$GG_LAYER" "$_HOME_DIR"
